var documenterSearchIndex = {"docs":
[{"location":"#ImmersedSplines","page":"Home","title":"ImmersedSplines","text":"","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#ImmersedSplines.active_splines-Tuple{CartesianProducts.TensorProduct{2, <:UnivariateSplines.SplineSpace}, Matrix{Int8}}","page":"Home","title":"ImmersedSplines.active_splines","text":"active_splines(U::TensorProduct{2, <:SplineSpace}, E::Array)\n\nDetermine the active B-splines and boundary B-splines given a  distance function ϕ.\n\nA[k] == 0 => no physical elements in support of the function A[k] == 1 => boundary function with a physical cut element in its support A[k] == 2 => at least one physical element is fully inside support A[k] == 3 => all physical elements are fully inside support\n\n\n\n\n\n","category":"method"},{"location":"#ImmersedSplines.active_splines-Tuple{CartesianProducts.TensorProduct{3, <:UnivariateSplines.SplineSpace}, Array{Int8, 3}}","page":"Home","title":"ImmersedSplines.active_splines","text":"active_splines(U::TensorProduct{Dim, <:SplineSpace}, E::Array)\n\nDetermine the active B-splines and boundary B-splines given a  distance function ϕ.\n\nA[k] == 0 => no physical elements in support of the function A[k] == 1 => boundary function with a physical cut element in its support A[k] == 2 => at least one physical element is fully inside support A[k] == 3 => all physical elements are fully inside support\n\n\n\n\n\n","category":"method"},{"location":"#ImmersedSplines.active_splines-Tuple{UnivariateSplines.SplineSpace, Vector{Int8}}","page":"Home","title":"ImmersedSplines.active_splines","text":"active_splines(U::TensorProduct{2, <:SplineSpace}, E::Array)\n\nDetermine the active B-splines and boundary B-splines given a  distance function ϕ.\n\nA[k] == 0 => no physical elements in support of the function A[k] == 1 => boundary function with a physical cut element in its support A[k] == 2 => at least one physical element is fully inside support A[k] == 3 => all physical elements are fully inside support\n\n\n\n\n\n","category":"method"},{"location":"#ImmersedSplines.compute_extension_coefficients-Tuple{Integer, Any, Int64, Int64}","page":"Home","title":"ImmersedSplines.compute_extension_coefficients","text":"compute_extension_coefficients(p, kts, span, k)\n\nCompute the extension coefficients using dual functionals. This works for general non-uniform knot vectors and is based on the paper [Höllig, Klaus,  and Ulrich Reif. \"Nonuniform web-splines.\" Computer Aided Geometric Design  20, no. 5 (2003): 277-294.]\n\n\n\n\n\n","category":"method"},{"location":"#ImmersedSplines.element_is_inside-Tuple{Any, Any}","page":"Home","title":"ImmersedSplines.element_is_inside","text":"elementisinside(Y::Matrix{Bool})\n\nReturn a boolean array that specifies whether an element is inside or  outside, respectively\n\n\n\n\n\n","category":"method"},{"location":"#ImmersedSplines.find_extension_indices-Tuple{Any, Any, Any}","page":"Home","title":"ImmersedSplines.find_extension_indices","text":"find_extension_indices(active_functions, gperm, mi)\n\nFind the extension indices that are closest to the boundary function with CartesianIndex mi.\n\n\n\n\n\n","category":"method"},{"location":"#ImmersedSplines.find_first_active_element-Tuple{Any, Any, Any}","page":"Home","title":"ImmersedSplines.find_first_active_element","text":"find_extension_indices(active_functions, gperm, mi)\n\nFind the extension indices that are closest to the boundary function with CartesianIndex mi.\n\n\n\n\n\n","category":"method"},{"location":"#ImmersedSplines.point_is_inside-Tuple{Any, Any}","page":"Home","title":"ImmersedSplines.point_is_inside","text":"pointisinside(phi, partition::CartesianProduct)\n\nReturn a boolean array that specifies whether a point is inside or  outside, respectively\n\n\n\n\n\n","category":"method"},{"location":"#ImmersedSplines.spline_extension_operator-Union{Tuple{Dim}, Tuple{CartesianProducts.TensorProduct{Dim, <:UnivariateSplines.SplineSpace}, Any}} where Dim","page":"Home","title":"ImmersedSplines.spline_extension_operator","text":"spline_extension_operator(U::TensorProduct{2, <:SplineSpace}, F)\n\nCompute an extension operator that stabilizes the splinespace according to the definition of [Höllig, Klaus, Ulrich Reif, and Joachim Wipper. \"Weighted extended  B-spline approximation of Dirichlet problems.\" SIAM Journal on Numerical Analysis 39,  no. 2 (2001): 442-462.]\n\n\n\n\n\n","category":"method"},{"location":"#ImmersedSplines.ClosestExtensionArray","page":"Home","title":"ImmersedSplines.ClosestExtensionArray","text":"ClosestExtensionArray(F, U::TensorProduct{Dim,<:SplineSpace})\n\nDefines a closest index array, according to the definition of  [Höllig, Klaus, Ulrich Reif, and Joachim Wipper. \"Weighted extended B-spline approximation of Dirichlet problems.\" SIAM Journal on Numerical Analysis 39,  no. 2 (2001): 442-462.]\n\n\n\n\n\n","category":"type"},{"location":"#ImmersedSplines.ClosestExtensionArray-Union{Tuple{CartesianIndex{Dim}}, Tuple{Dim}} where Dim","page":"Home","title":"ImmersedSplines.ClosestExtensionArray","text":"ClosestExtensionArray(F, U::TensorProduct{Dim,<:SplineSpace})\n\nComputes a closest index array, according to the definition of  [Höllig, Klaus, Ulrich Reif, and Joachim Wipper. \"Weighted extended B-spline approximation of Dirichlet problems.\" SIAM Journal on Numerical Analysis 39,  no. 2 (2001): 442-462.]\n\n\n\n\n\n","category":"method"},{"location":"#ImmersedSplines.GeneratePerimeter","page":"Home","title":"ImmersedSplines.GeneratePerimeter","text":"GeneratePerimeter{Dim,Indices}\n\nDatastructure that allows iteration over active neighborhoods of boundary  functions\n\n\n\n\n\n","category":"type"},{"location":"#ImmersedSplines.IPerm","page":"Home","title":"ImmersedSplines.IPerm","text":"IPerm{Dim,Indices}\n\nIterator that returns active neighborhoods around a B-spline.\n\n\n\n\n\n","category":"type"},{"location":"#ImmersedSplines.ImmersedQuadRule","page":"Home","title":"ImmersedSplines.ImmersedQuadRule","text":"ImmersedQuadRule(map::AlgoimMapping, xa::Real, ya::Real, xb::Real, yb::Real, qo::Int64)\n\nCompute a algoim quadrature rule in bounding box [xa, ya] × [xb, yb] based on a Gauss-Legendre rule of qo points.\n\n\n\n\n\n","category":"type"}]
}
